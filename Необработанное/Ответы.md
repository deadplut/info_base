### Базовые:

- Что такое `concurrent.futures` и зачем он нужен?
    это библиотека на основе ThreadPoolExecutor и ProcessPoolExecutor. Более высокоуровневый интерфейс
- Чем отличается `ThreadPoolExecutor` от `ProcessPoolExecutor`?
  один для потоков, другой для процессов
    
- В каких случаях лучше использовать потоки, а в каких — процессы?
- процессы, если доступны другие процессы, а также нет необходимости передавать данные между процессами. Также процессы лучше использовать для счётных задач. в остальных случая лучше использовать потоки
    
- Как использовать `.map()` и чем он отличается от встроенной `map()`?
    примерно также как и встроенная map используется, но теперь map выполняет 
	переданные функции в разных потоках или процессах.
### Углубленные:

- Что возвращает `executor.submit()`?
   возвращает объект FUture(предоставляющий ожидаемую операцию)
    
- Что такое `Future`? Как получить его результат?
- это аналог promise в JS. это будущие объекты, которые станут доступны после выполнения всего future.
    
- Как обрабатывать ошибки в задачах, выполняемых в Executor?
- как-то через методе .result(). в нем можно дополнительно вызывать исключение
    
- Как использовать `as_completed()`? Когда это удобно?
    для будущих объектов. которая принимает итерируемый объект, содержащий будущие объекты, и возвращает резултат объектов по мере выполнения

### Практика и применение:

- Как организовать параллельную загрузку файлов?
  при помощи 
    concurrent.futures который использует процессы/
    
- Как измерить разницу по времени между последовательным и параллельным исполнением?
  elapsed в map
    
- Как реагировать на завершение первой готовой задачи, а не ждать все?
  with executor:  for n, prime, elapsed in executor.map(check, numbers):  label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s')